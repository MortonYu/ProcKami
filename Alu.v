Require Import Kami.All RecordUpdate.RecordSet FU.
Require Import List.
Import RecordNotations.

Section Alu.
  Variable Xlen_over_8: nat.

  Notation Xlen := (8 * Xlen_over_8).

  Notation Data := (Bit Xlen).
  Notation VAddr := (Bit Xlen).
  Notation DataMask := (Bit Xlen_over_8).

  Notation createControl := (createControl Xlen_over_8).
  Notation createInt := (createInt Xlen_over_8).
  Notation createFloat := (createFloat Xlen_over_8).
  Notation createSimpleFloat := (createSimpleFloat Xlen_over_8).
  Notation createCsr := (createCsr Xlen_over_8).
  Notation createMem := (createMem Xlen_over_8).

  Section Ty.
  Variable ty: Kind -> Type.

  Definition AluType := STRUCT {"arg1" :: Data ; "arg2" :: Data}.

  Local Open Scope kami_expr.

  Definition fieldVal range value :=
    existT (fun x => word (fst x - snd x + 1)) range value.

  Definition AddEntry: @FUEntry Xlen_over_8 ty.
    refine
    {| fuName := "add" ;
       fuFunc := (fun i => LETE x: AluType <- i;
                             RetE ((#x @% "arg1") + (#x @% "arg2")));
       fuInsts := {| instName     := "addi" ;
                     uniqId       := (Normal, (fieldVal opcodeField ('b"00100") ::
                                                        (fieldVal funct3Field ('b"000")) :: nil)) ;
                     inputXform   := (fun gcpin => LETE gcp: ExecContextPkt Xlen_over_8 <- gcpin;
                                                     RetE ((STRUCT { "arg1" ::= #gcp @% "reg1";
                                                                     "arg2" ::= SignExtendTruncLsb Xlen ((#gcp @% "inst")$[24:13])
                                                           }): AluType @# _)) ;
                     outputXform  := (fun resultExpr => LETE result: Data <- resultExpr;
                                                          RetE (createInt #result)) ;
                     optLoadXform := None ;
                     instHints    := falseHints[hasRs1 := true][hasRd := true]
                  |} :: nil
    |}.

  match goal with
  | |- @Setter ?T _ ?A => unshelve eapply Build_Setter;
                        [ get_setter T A |
                          let r := fresh in
                          intros ? r; destruct r |
                          let r := fresh in
                          intros r; destruct r ];
                        intros; reflexivity
  end.


    SetInstance_t.

            outputXform
            := fun outarg
               => LETE out: Data <- outarg ;
            RetE (state_update_packet_int_inst out);
            optLoadXform := None
          |};
            {|
              instName := "add";
              uniqId
              := (Normal,
                  [binary_field bit_range_trunc_opcode ('b"01100");
                     binary_field bit_range_funct7 ('b"0000000");
                     binary_field bit_range_funct3 ('b"000")]);
              (* maps the context onto the semantic function arguments and reformats the context values as necessary. *)
              inputXform
              := fun contextExpr : LetExprSyntax ty (GenContextPkt Xlen_over_8)
                 => LETE context: GenContextPkt Xlen_over_8 <- contextExpr;
              RetE ((STRUCT {
                         "arg1" ::= #context @% "reg1";
                         "arg2" ::= #context @% "reg2"
                    }): AluType @# _);
              (* takes the value generated by the semantic function and returns a structure summarizing the state updates resulting from executing the instruction. *)
              outputXform
                    |}
      fuName
      := "add";
      fuFunc
      := fun i
         => LETE x: AluType <- i;
      RetE ((#x @% "arg1") + (#x @% "arg2"));
      fuInsts
      := [
          {|
            instName := "addi";
            uniqId
            := (Normal,
                [binary_field bit_range_trunc_opcode ('b"00100");
                   binary_field bit_range_funct3 ('b"000")]);
            |};
            {|
              instName := "sub";
              uniqId
              := (Normal,
                  [binary_field bit_range_trunc_opcode ('b"01100");
                     binary_field bit_range_funct7 ('b"0100000");
                     binary_field bit_range_funct3 ('b"000")]);
              inputXform
              := fun contextExpr : LetExprSyntax ty (GenContextPkt Xlen_over_8)
                 => LETE context : GenContextPkt Xlen_over_8 <- contextExpr;
              RetE ((STRUCT {
                         "arg1" ::= #context @% "reg1";
                         "arg2" ::= ~ (#context @% "reg2") + $1 (* twos complement *)
                    }) : AluType @# _);
              outputXform
              := fun resultExpr : LetExprSyntax ty (Bit Xlen)
                 => LETE result: Data <- resultExpr;
              RetE (state_update_packet_int_inst result);
              optLoadXform := None
            |}
        ]
    |}.

  Local Close Scope kami_expr.
  End Ty.
End Alu.
